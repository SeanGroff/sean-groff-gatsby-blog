{"componentChunkName":"component---node-modules-gatsby-theme-blog-core-src-templates-post-query-js","path":"/src/useReducer/","result":{"data":{"site":{"siteMetadata":{"title":"Sean Groff | Web Developer creating awesome content for JavaScript and React","social":[{"name":"Twitter","url":"https://twitter.com/_SeanGroff"},{"name":"GitHub","url":"https://github.com/seangroff"}]}},"blogPost":{"__typename":"MdxBlogPost","id":"b7d19ccd-4774-572b-8394-da44c4fc889b","excerpt":"Introduction The  useReducer  hook provides a flexible solution to complex state. The  useState  hook we all know and love is actually built…","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"The Approachable Guide to useReducer\",\n  \"date\": \"2019-05-20\",\n  \"categories\": \"react\",\n  \"tags\": [\"react\", \"hooks\", \"reducer\", \"useReducer\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h3\", {\n    \"id\": \"introduction\"\n  }, \"Introduction\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useReducer\"), \" hook provides a flexible solution to complex state. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useState\"), \" hook we all know and love is actually built on top of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useReducer\"), \". If you don\\u2019t understand how a reducer function works you\\u2019ll likely always reach for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useState\"), \". This isn\\u2019t the worst thing in the world, but I hope after reading this article you\\u2019ll understand exactly how to implement \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useReducer\"), \" and have a decent idea when to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useReducer\"), \".\"), mdx(\"h3\", {\n    \"id\": \"what-is-a-reducer\"\n  }, \"What is a Reducer?\"), mdx(\"p\", null, \"A Reducer is a function that takes two values and reduces them down to one value.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"function fullNameReducer(firstName, lastName) {\\n  return `${firstName} ${lastName}`\\n}\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fullNameReducer\"), \" function accepts two values as its parameters and returns one string value.\"), mdx(\"p\", null, \"The reducer function was popularized by Redux but existed long before Redux. I only say this because many people think \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Redux === Reducer\"), \". It\\u2019s important to go into this knowing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Redux !== Reducer\"), \".\"), mdx(\"h3\", {\n    \"id\": \"when-to-use-usereducer\"\n  }, \"When to use useReducer\"), mdx(\"p\", null, \"The first question I had when I first read the React docs was \\u201CWhen should I use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useReducer\"), \" instead of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useState\"), \". I\\u2019ve seen different opinions on this subject across the internet but I prefer \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useReducer\"), \" when I need to update more than a single entity. I\\u2019ll explain with code.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"useState Example\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"function useFetch(url) {\\n  const [data, setData] = React.useState(null)\\n  const [isLoading, setIsLoading] = React.useState(true)\\n  const [errorMessage, setErrorMessage] = React.useState('')\\n\\n  const fetchData = async () => {\\n    try {\\n      setErrorMessage('')\\n      const results = await axios.get(url)\\n      setData(results)\\n    } catch (error) {\\n      setErrorMessage(error.message || error)\\n    } finally {\\n      setIsLoading(false)\\n    }\\n  }\\n\\n  React.useEffect(() => {\\n    fetchData(url)\\n  }, [])\\n\\n  return { data, isLoading, errorMessage }\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"useReducer Example\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const fetchReducer = (state, action) => {\\n  switch (action.type) {\\n    case 'FAILURE':\\n      return { data: null, isLoading: false, errorMessage: action.error }\\n    case 'SUCCESS':\\n      return { data: action.data, isLoading: false, errorMessage: '' }\\n    default:\\n      return state\\n  }\\n}\\n\\nfunction useFetch(url) {\\n  const initialState = { data: null, isLoading: true, errorMessage: '' }\\n  const [state, dispatch] = React.useReducer(fetchReducer, initialState)\\n\\n  const fetchData = async () => {\\n    try {\\n      const results = await axios.get(url)\\n      dispatch({ type: 'SUCCESS', data })\\n    } catch (error) {\\n      dispatch({ type: 'FAILURE', error: error.message || error })\\n    }\\n  }\\n\\n  React.useEffect(() => {\\n    fetchData(url)\\n  }, [])\\n\\n  return state\\n}\\n\")), mdx(\"p\", null, \"It\\u2019s likely your initial reaction is to throw useReducer in the trash and go back to using useState based on the lines of code \\uD83E\\uDD23. At the end of the day this really comes down to developer preference anyways so you do you. It\\u2019s way to early for best practices to really be established. Lets focus on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useState\"), \" example and I\\u2019ll point out a few things.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"For each state entity I must declare a setter method.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"There is some bug prone cognitive overhead to getting this solution working right\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"If you are familiar with the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"useState\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"useReducer\"), \" API the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"useState\"), \" solution is slightly less declarative in this example.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"All the logic lives inside the Custom hook.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Difficult to test compared to a reducer function.\")), mdx(\"p\", null, \"Now lets focus on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useReducer\"), \" example and elaborate on the numbered list above.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"This one is simple, \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"useReducer\"), \" provides a single \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"dispatch\"), \" function I can reuse whenever I want to make a state change.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The cognitive overhead is reduced (no pun intended) to each switch case and the rationality of each state change lives on a single line of code, the object. If the fetch request was successful, I can reasonably set the three state values in one line with minimal cognitive overhead and quickly get the solution working.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"{ data: action.data, isLoading: false, errorMessage: ''}\\n\")), mdx(\"ol\", {\n    \"start\": 3\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"You\\u2019re probably reading this article to learn useReducer so come back later \\uD83D\\uDE0E\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The logic is isolated to the reducer function. The more logic, the stronger the use case for useReducer as it will be easier for other developers to comprehend.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"It will always be simpler to test a reducer function (plain JS) than a React Hook.\")), mdx(\"p\", null, \"Outside of this fetch example, it is common to pass a setter function. There are a couple nice things about passing dispatch vs a setState method. The docs have a great explanation \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down\"\n  }), \"here\"), \".\"), mdx(\"p\", null, \"Now that you have a decent opinion of when to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useReducer\"), \" instead of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useState\"), \" lets learn the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useReducer\"), \" API \\uD83D\\uDE80.\"), mdx(\"h3\", {\n    \"id\": \"learning-the-api\"\n  }, \"Learning the API\"), mdx(\"p\", null, \"First off, read the docs. Seriously, the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://reactjs.org/docs/hooks-reference.html#usereducer\"\n  }), \"React docs\"), \" are top notch and very approachable.\"), mdx(\"p\", null, \"With that out of the way, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useReducer\"), \" hook accepts three arguments. I\\u2019m only covering the first two arguments in this blog post. See? Reading the docs does matter! \\uD83E\\uDD14\"), mdx(\"h3\", {\n    \"id\": \"initial-state\"\n  }, \"Initial State\"), mdx(\"p\", null, \"To keep you on your toes I\\u2019m going to begin with the second argument to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useReducer\"), \" only because it\\u2019s simple to Grok and provides some mental context to the reducer function which is the first argument to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useReducer\"), \". If you\\u2019re familiar with Redux you can skip ahead.\"), mdx(\"p\", null, \"Typically, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"initialState\"), \" is a JavaScript Object. If you read the previous paragraph on when to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useReducer vs useState\"), \" than \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"initialState\"), \" will always be an Object \\uD83D\\uDE07. It\\u2019s an important takeaway to know the initial state can be ANY value. This is why you\\u2019ll notice in the docs they introduce \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"initialState\"), \" as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"initialArg\"), \".\"), mdx(\"p\", null, \"You can define the initialState inline as the second argument to useReducer but typically you defined initialState as a variable first.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Defined Inline would look something like this:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const [state, dispatch] = React.useReducer(exampleReducer, 0)\\n\")), mdx(\"p\", null, \"Two things to note here, the first being the obvious. We declared the initial state inline as the second argument to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useReducer\"), \". Next, remember how I said the initial state can be ANY value? In this example, the initial state is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0\"), \".\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Declaring your initial state first\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const initialState = 0\\nconst [state, dispatch] = React.useReducer(exampleReducer, initialState)\\n\")), mdx(\"p\", null, \"In a more real world example, you would likely define initial state inline if the initial state is a simple primitive value.\"), mdx(\"h3\", {\n    \"id\": \"reducer\"\n  }, \"Reducer\"), mdx(\"p\", null, \"The first argument to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useReducer\"), \" is a reducer function. The blueprint for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useReducer\"), \" reducer function is:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"function reducer(prevState, action) {\\n  // insert logic that results in a new state\\n\\n  return newState\\n}\\n\")), mdx(\"p\", null, \"Reducer accepts the previous state for its first argument and the action for its second argument. The body of the reducer will contain whatever logic needed to create new state and return it. Remember, a reducer function accepts 2 values and returns 1 value.\"), mdx(\"p\", null, \"Something that may not be obvious at first is the action can be anything\\u2026including a function!\"), mdx(\"h3\", {\n    \"id\": \"return-value-of-usereducer\"\n  }, \"Return value of useReducer\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useReducer\"), \" hook returns an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Array\"), \" of two items. The first item is always your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"state\"), \". The second item is always a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dispatch\"), \" function.\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"state\"), \" returned is always the return value from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reducer\"), \" function.\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dispatch\"), \" function is a void type function (a function with no return value) and the blueprint looks like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"function dispatch(action) {\\n  // void\\n}\\n\")), mdx(\"p\", null, \"An important takeaway here is the argument (action) passed into \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dispatch\"), \" is the second argument passed passed into the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reducer\"), \" function.\"), mdx(\"p\", null, \"Example 1:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"dispatch({ type: 'SUCCESS' })\\n\\nfunction reducer(prevState, action) {\\n  console.log(action) // {type: 'SUCCESS'}\\n}\\n\")), mdx(\"p\", null, \"Example 2:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"dispatch(7)\\n\\nfunction reducer(prevState, action) {\\n  console.log(action) // 7\\n}\\n\")), mdx(\"p\", null, \"Example 3:\"), mdx(\"p\", null, \"Remember I said an action could be anything including a function?\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"dispatch(a => a + b)\\n\\nfunction reducer(prevState, action) {\\n  console.log(action) // function(a) { return a + b }\\n}\\n\")), mdx(\"p\", null, \"Hopefully you\\u2019re starting to see just how flexible \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useReducer\"), \" can be!\"), mdx(\"p\", null, \"Speaking of flexibility, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useReducer\"), \" returns an Array of two items. Thanks to JavaScript array destructuring you can name the two items whatever makes sense.\"), mdx(\"p\", null, \"\\u2622\\uFE0FContrived Example Warning \\u2622\\uFE0F\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const [name, setName] = React.useReducer(nameReducer, 'Sean')\\n\")), mdx(\"h3\", {\n    \"id\": \"conclusion\"\n  }, \"Conclusion\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useReducer\"), \" hook is categorized as an advanced hook in the React docs. When compared to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useState\"), \" I\\u2019d agree. However, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \" is a basic hook but is far more advanced to learn than \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useReducer\"), \". My worry is this categorization prevents some from exploring \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useReducer\"), \" when \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useState\"), \" works well enough. Hopefully reading this article shows how approachable and flexible \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useReducer\"), \" is \\uD83D\\uDE0E.\"), mdx(\"p\", null, \"P.S. When the React docs say Basic/Advanced I believe Core/Specialized may be more accurate \\uD83E\\uDD37\\u200D\\u2642\\uFE0F.\"));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/src/useReducer/","title":"The Approachable Guide to useReducer","tags":["react","hooks","reducer","useReducer"],"keywords":[],"date":"May 20, 2019"},"previous":{"__typename":"MdxBlogPost","id":"d8bc964a-e9d1-5865-893e-b7aff488d0b8","excerpt":"What are Animations in React Native? Animation  can be defined as manipulating images or objects to appear as moving images or objects…","slug":"/src/rn-animations/","title":"Get Started with React Native Animations","date":"August 29, 2018"},"next":{"__typename":"MdxBlogPost","id":"da076743-32db-53c8-8d9b-26fdeae8f49e","excerpt":"The Journey Why the hell did I take an AWS certification exam as primarily a front-end developer? Learning cloud services is a NECESSARY…","slug":"/src/aws-ccp/","title":"My AWS Cloud Journey as a Front-end Developer","date":"November 02, 2019"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"b7d19ccd-4774-572b-8394-da44c4fc889b","previousId":"d8bc964a-e9d1-5865-893e-b7aff488d0b8","nextId":"da076743-32db-53c8-8d9b-26fdeae8f49e"}}}